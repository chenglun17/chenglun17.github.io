(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{579:function(_,v,t){"use strict";t.r(v);var s=t(10),r=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"第七章-查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第七章-查找"}},[_._v("#")]),_._v(" 第七章--查找")]),_._v(" "),v("p",[v("strong",[_._v("静态")]),_._v("查找表的查找方法：顺序查找、折半查找、散列查找")]),_._v(" "),v("p",[v("strong",[_._v("动态")]),_._v("查找表的查找方法：二叉排序树的查找、散列查找")]),_._v(" "),v("p",[_._v("关键字：数据元素中唯一标识该元素的某个数据项的值")]),_._v(" "),v("p",[_._v("平均查找长度ASL")]),_._v(" "),v("h2",{attrs:{id:"_7-1-顺序查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-顺序查找"}},[_._v("#")]),_._v(" 7.1 顺序查找")]),_._v(" "),v("p",[_._v("顺序查找（线性查找），对于"),v("strong",[_._v("顺序表")]),_._v("和"),v("strong",[_._v("链表")]),_._v("都适用，时间复杂度为 O(n)")]),_._v(" "),v("ul",[v("li",[_._v("ASL成功 = (n+1) / 2")]),_._v(" "),v("li",[_._v("ASL不成功 = n+1 ，不成功是位置是1个（哨兵只有1个）")])]),_._v(" "),v("p",[_._v("对线性的链表只能进行顺序查找")]),_._v(" "),v("h2",{attrs:{id:"_7-2-折半查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-折半查找"}},[_._v("#")]),_._v(" 7.2 折半查找")]),_._v(" "),v("p",[_._v("折半查找（二分查找），仅适用于"),v("strong",{staticStyle:{color:"#DD5145"}},[_._v("有序的顺序表（可随机存取）")]),_._v("，不适用于链表，时间复杂度为 O(log2 n)")]),_._v(" "),v("p",[_._v("折半查找的过程可用一个二叉树来描述，称为"),v("strong",[_._v("判定树")]),_._v("（折半树或二叉搜索树），判定树是一颗"),v("strong",[_._v("平衡二叉树")])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("判定树的次数只和元素的个数有关，而与元素具体什么内容无关")]),_._v(" "),v("li",[_._v("每个结点值均大于其左子结点值，且均小于其右子结点值")]),_._v(" "),v("li",[_._v("比较"),v("strong",[_._v("次数")]),_._v("最多不会超过树的高度 h =【log2 (n+1)】(向上取整)")])])]),_._v(" "),v("h2",{attrs:{id:"_7-3-分块查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-分块查找"}},[_._v("#")]),_._v(" 7.3 分块查找")]),_._v(" "),v("p",[_._v("分块查找（索引顺序查找），块内无序（顺序查找），块间有序（可顺序、折半）")]),_._v(" "),v("blockquote",[v("p",[_._v("长度为 n 的查找表均匀地分为 b 块，每块有 s 个记录，Li为索引查找的ASL，Ls为块内查找的ASL")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("块内和索引表都采用顺序查找")]),_._v(" "),v("p",[_._v("ASL = Li + Ls = (b+1)/2 + (s+1)/2 = （s^2 + 2s + n）/ 2s")]),_._v(" "),v("p",[_._v("若s = 根号n时，ASL取的最小值 根号n +1")])]),_._v(" "),v("li",[v("p",[_._v("索引表采用折半查找")]),_._v(" "),v("p",[_._v("ASL =【log2 (b+1)】+（s+1）/ 2，（向上取整）")])]),_._v(" "),v("li",[v("p",[_._v("若s = 根号n时，ASL取的最小值 根号n +1")])])])]),_._v(" "),v("p",[v("strong",[_._v("线性结构")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th"),_._v(" "),v("th",[_._v("顺序查找")]),_._v(" "),v("th",[_._v("折半查找(二分查找)")]),_._v(" "),v("th",[_._v("分块查找")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("时间复杂度")]),_._v(" "),v("td",[_._v("O(n)")]),_._v(" "),v("td",[_._v("O(log2 n)")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("空间复杂度")]),_._v(" "),v("td"),_._v(" "),v("td"),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("ASL成功")]),_._v(" "),v("td",[_._v("(n+1) / 2")]),_._v(" "),v("td"),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("ASL失败")]),_._v(" "),v("td",[_._v("n+1")]),_._v(" "),v("td"),_._v(" "),v("td")])])]),_._v(" "),v("h2",{attrs:{id:"_7-4-树型查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-树型查找"}},[_._v("#")]),_._v(" 7.4 树型查找")]),_._v(" "),v("h3",{attrs:{id:"_7-4-1-二叉排序树-bst"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-1-二叉排序树-bst"}},[_._v("#")]),_._v(" 7.4.1 二叉排序树（BST）")]),_._v(" "),v("p",[_._v("一颗二叉排序树（二叉查找树）或是一颗空树：")]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("若左子树为空，则左子树上所有结点的值均小于根结点的值")]),_._v(" "),v("li",[_._v("若右子树为空，则右子树上所有结点的值均大于根结点的值")]),_._v(" "),v("li",[_._v("左、右子树也分别是一颗二叉排序树")])]),_._v(" "),v("p",[v("strong",{staticStyle:{color:"#DD5145"}},[_._v("左子树结点值 < 根结点 < 右子树结点值")])]),_._v(" "),v("p",[_._v("所以，对二叉树进行"),v("strong",{staticStyle:{color:"#DD5145"}},[_._v("中序遍历")]),_._v("，可以得到一个"),v("strong",{staticStyle:{color:"#DD5145"}},[_._v("递增")]),_._v("的有序序列")])]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("BST 的查找")])]),_._v(" "),v("p",[_._v("ASL与树的深度是等数量级")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("BST 的插入")])]),_._v(" "),v("p",[_._v("插入的结点一定是一个新添加的"),v("strong",[_._v("叶子结点")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("BST 的构造")])]),_._v(" "),v("p",[_._v("关键字的输入顺序不同，建立的二叉排序树不同")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("BST 的删除")])])])]),_._v(" "),v("blockquote",[v("ol",[v("li",[_._v("若被删除结点 z 是叶结点，则直接删除")]),_._v(" "),v("li",[_._v("若结点 z 只有一颗左子树或右子树，则让 z 的子树成为父结点的子树，代替 z 的位置")]),_._v(" "),v("li",[_._v("若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）代替 z，然后变成 1 或 2")])])]),_._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[v("p",[v("strong",[_._v("BST 的查找效率")])]),_._v(" "),v("p",[_._v("二叉排序树的查找效率，主要取决于树的高度")]),_._v(" "),v("p",[_._v("最好的时间复杂度：O(log2 n)")]),_._v(" "),v("p",[_._v("最坏的时间复杂度：O(n)")])])]),_._v(" "),v("h3",{attrs:{id:"_7-4-2-平衡二叉树-avl树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-2-平衡二叉树-avl树"}},[_._v("#")]),_._v(" 7.4.2 平衡二叉树（AVL树）")]),_._v(" "),v("p",[_._v("平衡二叉树：任意结点的左、右子树高度差的绝对值不超过1，即"),v("strong",[_._v("平衡因子")]),_._v("（左子树高 - 右子树高）的值只可能是-1,0,1")]),_._v(" "),v("p",[_._v("插入、删除和查找在平均和最坏情况下的时间复杂度都为 O(log2 n)")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[v("strong",[_._v("AVL树的插入")])]),_._v(" "),v("p",[_._v('插入和删除会破坏 "平衡" 特性，导致 AVL树 ==失衡==：LL型、LR型、RL型、RR型')])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("AVL树的删除")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("AVL树的查找")])]),_._v(" "),v("p",[_._v("深度为 h 的平衡二叉排序树所具有的最少结点数为 Nn，则 N0 = 0，N1 = 1，N2 = 2，...，==Nh = N(h-1) + N(h-2) + 1==")]),_._v(" "),v("p",[_._v("平衡二叉树的ASL为 O(log2 n)")])])])]),_._v(" "),v("h3",{attrs:{id:"_7-4-3-红黑树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-3-红黑树"}},[_._v("#")]),_._v(" 7.4.3 红黑树")]),_._v(" "),v("p",[v("strong",[_._v("1. 红黑树的性质")])]),_._v(" "),v("p",[_._v("红黑树也是一种 "),v("strong",[_._v("平衡")]),_._v("（特殊的平衡）二叉排序树")]),_._v(" "),v("p",[_._v("一颗红黑树是满足如下红黑性质的 "),v("strong",[_._v("二叉排序树")]),_._v("：")]),_._v(" "),v("blockquote",[v("ol",[v("li",[_._v("每个结点或是红色，或是黑色的")]),_._v(" "),v("li",[_._v("**根 **结点是 "),v("strong",[_._v("黑")]),_._v(" 色的")]),_._v(" "),v("li",[v("strong",[_._v("叶子")]),_._v(" 结点（虚构的外部结点、NULL结点）都是 "),v("strong",[_._v("黑")]),_._v(" 色的")]),_._v(" "),v("li",[_._v("不存在两个相邻的红结点（即 ==红== 结点的父结点和孩子结点均是黑色）")]),_._v(" "),v("li",[_._v("对每个结点，从该结点出发到任意一个叶子结点的简单了路径上，所含黑结点的数量相同（"),v("strong",[_._v("黑高相同")]),_._v("）")])]),_._v(" "),v("p",[v("strong",[_._v("左根右，根叶黑；不红红，黑路同")])])]),_._v(" "),v("blockquote",[v("p",[_._v("根结点的黑高称为红黑树的树高，从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点的总数")]),_._v(" "),v("ul",[v("li",[_._v("结论1：从根结点到叶子结点的最长路径长度不大于最短路径的 "),v("strong",[_._v("2 倍")])]),_._v(" "),v("li",[_._v("结论2：有 n 个内部结点的红黑树的"),v("strong",[_._v("高度")]),_._v(" h <= "),v("strong",[_._v("2 * log2 (n+1)")])]),_._v(" "),v("li",[_._v("结论3：新插入红黑树的结点初始都为红色")])])]),_._v(" "),v("p",[v("strong",[_._v("2. 红黑树的插入")])]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[_._v("先查找，确定插入位置（原理同二叉排序树），插入新结点")])]),_._v(" "),v("li",[v("p",[_._v("新结点是 "),v("strong",[_._v("根")]),_._v("，则染为 "),v("strong",[_._v("黑色")])])]),_._v(" "),v("li",[v("p",[_._v("新结点是 "),v("strong",[_._v("非根")]),_._v("，则染为 "),v("strong",[_._v("红色")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("若插入新结点后仍然满足红黑树定义，则插入结束")])]),_._v(" "),v("li",[v("p",[_._v("若插入新结点后不满足红黑树定义，则进行 "),v("strong",[_._v("调整")]),_._v("，使其满足红黑树定义")]),_._v(" "),v("p",[_._v('调整：看新结点叔叔的 "脸色"')]),_._v(" "),v("p",[v("strong",[_._v("叔黑")]),_._v(" 则 "),v("strong",[_._v("旋转")]),_._v("＋"),v("strong",[_._v("染色")]),_._v("（LL、RR旋转，自己不变，然后父和爷的颜色互换，LR、RL旋转，然后自己和爷的颜色互换）")]),_._v(" "),v("p",[v("strong",[_._v("叔红")]),_._v(" 则 "),v("strong",[_._v("染色")]),_._v("＋"),v("strong",[_._v("变新")]),_._v("（自己不变，叔父爷染色，即黑变红，红变黑，然后爷变新结点，这个新结点需要从头开始判断）")])])])])])]),_._v(" "),v("p",[v("strong",[_._v("3. 红黑树的删除")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th"),_._v(" "),v("th",[_._v("二叉排序树（BST）")]),_._v(" "),v("th",[_._v("平衡二叉树（AVL）树")]),_._v(" "),v("th",[_._v("红黑树")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("时间复杂度-查找")]),_._v(" "),v("td",[_._v("O(n)")]),_._v(" "),v("td",[_._v("O(log2 n)")]),_._v(" "),v("td",[_._v("O(log2 n)")])]),_._v(" "),v("tr",[v("td",[_._v("时间复杂度-插入")]),_._v(" "),v("td",[_._v("O(n)")]),_._v(" "),v("td",[_._v("O(log2 n)")]),_._v(" "),v("td",[_._v("O(log2 n)")])]),_._v(" "),v("tr",[v("td",[_._v("时间复杂度-删除")]),_._v(" "),v("td",[_._v("O(n)")]),_._v(" "),v("td",[_._v("O(log2 n)")]),_._v(" "),v("td",[_._v("O(log2 n)")])])])]),_._v(" "),v("h2",{attrs:{id:"_7-5-b-树与-b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-b-树与-b-树"}},[_._v("#")]),_._v(" 7.5 B 树与 B+ 树")]),_._v(" "),v("h3",{attrs:{id:"_7-5-1-b-树-b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-1-b-树-b-树"}},[_._v("#")]),_._v(" 7.5.1 B 树（B-树）")]),_._v(" "),v("p",[_._v("二叉排序树是二路查找，B树是"),v("strong",[_._v("多路平衡查找")]),_._v("，支持"),v("strong",[_._v("随机查找")])]),_._v(" "),v("p",[_._v("B树的阶：所有结点的孩子的最大值")]),_._v(" "),v("p",[_._v("==一颗 m 阶 B 树== 或是一颗空树：")]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("树中每个结点"),v("strong",[_._v("至多")]),_._v("有 "),v("strong",[_._v("m 颗子树")]),_._v("（ "),v("strong",[_._v("m-1 个关键字")]),_._v("）")]),_._v(" "),v("li",[_._v("若"),v("strong",[_._v("根结点")]),_._v("不是终端结点，则至少有 2 棵子树（至少 1 个关键字）")]),_._v(" "),v("li",[_._v("除"),v("strong",[_._v("根结点外")]),_._v("的所有"),v("strong",[_._v("非叶结点")]),_._v(" "),v("strong",[_._v("至少")]),_._v("有**【m/2】颗子树**（"),v("strong",[_._v("【m/2】- 1个关键字")]),_._v("，向上取整）")]),_._v(" "),v("li",[_._v("所有的"),v("strong",[_._v("叶结点")]),_._v("都出现在同一层次上，并且"),v("strong",[_._v("不携带信息")])])])]),_._v(" "),v("p",[_._v("B树是所有结点的平衡因子均等于0的多路平衡查找树")]),_._v(" "),v("h3",{attrs:{id:"_7-5-2-b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-2-b-树"}},[_._v("#")]),_._v(" 7.5.2 B+ 树")]),_._v(" "),v("p",[_._v("B+树的所有"),v("strong",[_._v("非叶子结点")]),_._v("可以看成是"),v("strong",[_._v("索引")]),_._v("，支持"),v("strong",[_._v("随机查找")]),_._v("或"),v("strong",[_._v("顺序查找")])]),_._v(" "),v("p",[_._v("==一颗 m 阶 B+树== 需满足下列条件：")]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("每个分支结点"),v("strong",[_._v("至多")]),_._v("有 "),v("strong",[_._v("m 颗子树")]),_._v("（孩子结点）")]),_._v(" "),v("li",[_._v("非叶"),v("strong",[_._v("根结点")]),_._v("至少有 2 颗子树，其他每个分支结点"),v("strong",[_._v("至少")]),_._v("有**【m/2】颗子树**（向上取整）")]),_._v(" "),v("li",[_._v("结点的子树个数与关键字个数相等（一个结点有 "),v("strong",[_._v("m 颗子树")]),_._v("，则必含有 "),v("strong",[_._v("m 个关键字")]),_._v("）")]),_._v(" "),v("li",[_._v("所有"),v("strong",[_._v("叶结点")]),_._v("包含全部关键字、信息")])])]),_._v(" "),v("p",[_._v("B+树的两种查找运算：一种是"),v("strong",[_._v("从最小关键字开始的顺序查找")]),_._v("，另一种是"),v("strong",[_._v("从根结点开始的多路查找")])]),_._v(" "),v("p",[_._v("在 B+树的查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径")]),_._v(" "),v("h3",{attrs:{id:"_7-5-3-b-树的高度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-3-b-树的高度"}},[_._v("#")]),_._v(" 7.5.3 B 树的高度")]),_._v(" "),v("p",[_._v("B树的查找次数等价于B树的高度（==磁盘存取次数==）")]),_._v(" "),v("p",[_._v("含有 "),v("strong",[_._v("n 个关键字")]),_._v("，m 阶B树的 ==树高 h== 的范围："),v("strong",[_._v("logm (n+1)")]),_._v(" <= h <= "),v("strong",[_._v("log【m/2】[(n+1)/2] + 1")]),_._v("（向下取整）")]),_._v(" "),v("h3",{attrs:{id:"_7-5-4-b-树的查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-4-b-树的查找"}},[_._v("#")]),_._v(" 7.5.4 B 树的查找")]),_._v(" "),v("p",[_._v("查找：先在 B 树中找结点，然后在结点中找关键字")]),_._v(" "),v("p",[_._v("结点间（随机查找），结点内（顺序或折半查找）")]),_._v(" "),v("p",[_._v("查找到"),v("strong",[_._v("叶结点")]),_._v("时（对应指针为"),v("strong",[_._v("空指针")]),_._v("），则说明树中没有对应的关键字，"),v("strong",[_._v("查找失败")])]),_._v(" "),v("h3",{attrs:{id:"_7-5-5-b-树的插入"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-5-b-树的插入"}},[_._v("#")]),_._v(" 7.5.5 B 树的插入")]),_._v(" "),v("p",[_._v("插入位置一定是最低层中的某个非叶结点")]),_._v(" "),v("p",[_._v("当插入后的结点关键字个数"),v("strong",[_._v("大于 m-1")]),_._v(" 时，必须对结点进行 ==分裂==（裂变），只有根结点发生裂变时，B树的树高才会增高")]),_._v(" "),v("blockquote",[v("p",[_._v("分裂：【m/2】(向上取整)，"),v("strong",[_._v("左部分")]),_._v("的关键字放在"),v("strong",[_._v("原结点")]),_._v("，"),v("strong",[_._v("右部分")]),_._v("的关键字放在"),v("strong",[_._v("新结点")]),_._v("，"),v("strong",[_._v("中间")]),_._v("的结点插入原结点的"),v("strong",[_._v("父结点")])])]),_._v(" "),v("h3",{attrs:{id:"_7-5-6-b-树的删除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-6-b-树的删除"}},[_._v("#")]),_._v(" 7.5.6 B 树的删除")]),_._v(" "),v("p",[_._v("当被删除关键字 k 不在终端结点（最底层非叶子结点）中时")]),_._v(" "),v("blockquote",[v("p",[_._v("用直接前驱或直接后继来代替被删除的关键字")])]),_._v(" "),v("p",[_._v("当别删除关键字 k 在终端结点（最底层非叶结点）中时")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[_._v("**直接删除关键字：**被删除的关键字所在结点的关键字个数 >=【m/2】（向上取整）")])]),_._v(" "),v("li",[v("p",[_._v("**兄弟够借：**被删除的关键字所在结点的关键字个数 = 【m/2】- 1（向上取整）")]),_._v(" "),v("p",[_._v("父亲下，兄弟上")]),_._v(" "),v("p",[_._v("右兄弟找最小值")]),_._v(" "),v("p",[_._v("左兄弟找最大值")])]),_._v(" "),v("li",[v("p",[_._v("**兄弟不够借，向父亲借：**被删除的关键字所在结点的关键字个数 = 【m/2】- 1（向上取整），")]),_._v(" "),v("p",[_._v("且相邻左右兄弟结点关键字个数均"),v("strong",[_._v("等于【m/2】- 1")]),_._v("，则将关键字删除后与（或右）兄弟结点及双亲结点中的关键字进行 ==合并==")])])])]),_._v(" "),v("h2",{attrs:{id:"_7-6-散列-hash-表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-散列-hash-表"}},[_._v("#")]),_._v(" 7.6 散列（Hash）表")]),_._v(" "),v("h3",{attrs:{id:"_7-6-1-散列函数的构造方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-1-散列函数的构造方法"}},[_._v("#")]),_._v(" 7.6.1 散列函数的构造方法")]),_._v(" "),v("p",[_._v("除留余数法："),v("strong",[_._v("H(key) = key % p")])]),_._v(" "),v("h3",{attrs:{id:"_7-6-2-处理冲突的方法、"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-2-处理冲突的方法、"}},[_._v("#")]),_._v(" 7.6.2 处理冲突的方法、")]),_._v(" "),v("p",[_._v("一、开放定址法")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("1.线性探测法")])]),_._v(" "),v("p",[_._v("冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元或查遍全表")]),_._v(" "),v("ul",[v("li",[_._v("缺点：会造成大量元素在相邻的散列地址上 “聚集” 或 “堆积”，大大降低查找效率")])]),_._v(" "),v("p",[_._v("==“堆积”== 是因为选取的"),v("strong",[_._v("处理冲突方法")]),_._v("不合适导致的，ASL会因为 “堆积” 而增大")])]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("2.二次探测法（平方探测法）")])]),_._v(" "),v("p",[_._v("di = 1^2^，-1^2^，2^2^，-2^2^，...，k^2^，-k^2^，其中 k $\\leqslant$ m/2，m为散列表长度")]),_._v(" "),v("p",[_._v("前一步，后一步")]),_._v(" "),v("ul",[v("li",[_._v("优点：可以避免出现 “堆积” 问题")]),_._v(" "),v("li",[_._v("缺点：不能探测到散列表上的所有单元，但至少能探测到一半单元")])])]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("3.双散列法")])])]),_._v(" "),v("p",[_._v("二、链地址法（拉链法）")]),_._v(" "),v("h3",{attrs:{id:"_7-6-3-平均查找长度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-3-平均查找长度"}},[_._v("#")]),_._v(" 7.6.3 平均查找长度")]),_._v(" "),v("p",[v("strong",{staticStyle:{color:"#DD5145"}},[_._v("散列表查找方法的ASL与元素个数无关")]),_._v("。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("ASL成功")]),_._v(" = 查找次数 / 元素个数")]),_._v(" "),v("p",[v("strong",[_._v("ASL不成功")]),_._v(" = 查找次数 / 散列后的地址个数")])]),_._v(" "),v("p",[_._v("散列表的查找效率取决于三个因素："),v("strong",[_._v("散列函数")]),_._v("、"),v("strong",[_._v("处理冲突的方法")]),_._v("、"),v("strong",[_._v("装填因子")])]),_._v(" "),v("blockquote",[v("p",[_._v("==装填因子==："),v("strong",[_._v("α = 表中记录数n / 散列表长度m")])]),_._v(" "),v("p",[_._v("ASL与装填因子α 直接相关，不直接依赖 n 或 m")]),_._v(" "),v("p",[_._v("装填因子α "),v("strong",[_._v("越大")]),_._v("，表示装填的记录 "),v("strong",[_._v("越 “满”")]),_._v("，发生冲突的可能性越大")]),_._v(" "),v("p",[_._v("但是冲突是不可避免的，与装填因子α 无关")])])])}),[],!1,null,null,null);v.default=r.exports}}]);