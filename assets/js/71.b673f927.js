(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{561:function(t,_,a){"use strict";a.r(_);var v=a(10),s=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"第三章-栈、队列和数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三章-栈、队列和数组"}},[t._v("#")]),t._v(" 第三章--栈、队列和数组")]),t._v(" "),_("h2",{attrs:{id:"_3-1-栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-栈"}},[t._v("#")]),t._v(" 3.1 栈")]),t._v(" "),_("blockquote",[_("ol",[_("li",[_("p",[_("strong",[t._v("什么时候栈空？")])]),t._v(" "),_("p",[t._v("S.top == S.bottom == ==-1==，出栈之前要先判断栈是否为空")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("如何进栈？")])]),t._v(" "),_("p",[t._v("进栈先判断栈是否为满栈，==然后 S.top ++，最后 push 元素==，否则产生上溢")]),t._v(" "),_("p",[t._v("因为初始化时 S.top == -1，是不合法的范围，所以要 S.top ++")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("栈顶指针指向哪里？")])]),t._v(" "),_("p",[t._v("栈顶指针 top 指向栈顶元素")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("如何出栈？")])]),t._v(" "),_("p",[t._v("出栈先判断栈是否为空栈，==然后 pop 元素，最后 S.top --==，否则产生下溢")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("栈底指针指向哪里？")])]),t._v(" "),_("p",[t._v("栈底指针固定不变，指向初始的位置")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("什么时候满栈？")])]),t._v(" "),_("p",[t._v("静态顺序栈：当 S.top == n-1 时，栈满")]),t._v(" "),_("p",[t._v("动态顺序栈：当 |S.top - S.bottom| >= n 时，栈满")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("栈中元素有几个？")])]),t._v(" "),_("p",[t._v("有 |S.top - S.bottom| 个元素")])])]),t._v(" "),_("p",[t._v("以上问题与栈的初始化有关")]),t._v(" "),_("p",[t._v("默认情况是 S.top == S.bottom == ==0==，即 ==进栈时，先 push，后 top ++==；==出栈时，先 top --，后 pop==")]),t._v(" "),_("p",[t._v("还有另外两种情况 top == bottom == n（或 n+1），即以高端地址作为栈底")])]),t._v(" "),_("blockquote",[_("ul",[_("li",[t._v("上溢（overflow）：栈已经满了，还要 push 元素（一种错误）")]),t._v(" "),_("li",[t._v("下溢（underflow）：栈已经空了，还要 pop 元素（结束条件）")])])]),t._v(" "),_("h3",{attrs:{id:"_3-1-1-顺序栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-顺序栈"}},[t._v("#")]),t._v(" 3.1.1 顺序栈")]),t._v(" "),_("h3",{attrs:{id:"_3-1-2-链栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-链栈"}},[t._v("#")]),t._v(" 3.1.2 链栈")]),t._v(" "),_("h3",{attrs:{id:"_3-1-3-栈的基本操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-栈的基本操作"}},[t._v("#")]),t._v(" 3.1.3 栈的基本操作")]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("进栈")]),t._v("，栈顶指针为top，插入一个x结点")]),t._v(" "),_("p",[_("strong",[t._v("不带头结点")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("x->next=top; top=x;\n")])])]),_("p",[_("strong",[t._v("带头结点")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("x->next=top->next; top->next=x;\n")])])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("出栈")]),t._v("，栈顶指针为top，并将出栈元素存在x中")]),t._v(" "),_("p",[_("strong",[t._v("不带头结点")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("x=top->data; top=top->next;\n")])])]),_("p",[_("strong",[t._v("带头结点")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("x=top->next->data; top->next=top->next->next;\n")])])])])]),t._v(" "),_("h2",{attrs:{id:"_3-2-队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-队列"}},[t._v("#")]),t._v(" 3.2 队列")]),t._v(" "),_("h3",{attrs:{id:"_3-2-1-顺序队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-顺序队列"}},[t._v("#")]),t._v(" 3.2.1 顺序队列")]),t._v(" "),_("h3",{attrs:{id:"_3-2-2-循环队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-循环队列"}},[t._v("#")]),t._v(" 3.2.2 循环队列")]),t._v(" "),_("h3",{attrs:{id:"_3-2-3-链队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-链队列"}},[t._v("#")]),t._v(" 3.2.3 链队列")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("入队操作")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("s->data=x; s->next=NULL;\t//创建新节点s，数据域为x，插入到链尾，故s->next必须置为空\nQ.rear->next=s;\nQ.rear=s;\n")])])])]),t._v(" "),_("li",[_("p",[t._v("出队操作")])])]),t._v(" "),_("h3",{attrs:{id:"_3-2-4-双端队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-双端队列"}},[t._v("#")]),t._v(" 3.2.4 双端队列")]),t._v(" "),_("h2",{attrs:{id:"_3-3-栈的应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-栈的应用"}},[t._v("#")]),t._v(" 3.3 栈的应用")]),t._v(" "),_("h3",{attrs:{id:"括号匹配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#括号匹配"}},[t._v("#")]),t._v(" 括号匹配")]),t._v(" "),_("h3",{attrs:{id:"进制转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进制转换"}},[t._v("#")]),t._v(" 进制转换")]),t._v(" "),_("h3",{attrs:{id:"函数递归调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数递归调用"}},[t._v("#")]),t._v(" 函数递归调用")]),t._v(" "),_("h3",{attrs:{id:"表达式求值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#表达式求值"}},[t._v("#")]),t._v(" 表达式求值")]),t._v(" "),_("blockquote",[_("ol",[_("li",[_("p",[t._v("转换前先建立两个栈，命名为 s1 和 s2。用栈 s1 存储表达式的操作数，栈 s2 存储运算符")])]),t._v(" "),_("li",[_("p",[t._v("在转换的过程中，需要从左到右扫描中缀表达式的每一个操作数和运算符，若为操作数则压入栈 s1")])]),t._v(" "),_("li",[_("p",[t._v("若扫描到的是运算符，设符号为 C，则可能出现以下情况：")]),t._v(" "),_("p",[t._v("a.若 s2 为 ==空==，则将 C 压入到栈 s2 中")]),t._v(" "),_("p",[t._v("b.若 s2 的 ==栈顶符号为左括号==，则将 C 压入到栈 s2 中")]),t._v(" "),_("p",[t._v("c.若 C 为 ==左括号==，则将 C 压入到栈 s2 中")]),t._v(" "),_("p",[t._v("d.若 C 的优先级 ==大于== s2 的栈顶符号的优先级，则将 C 压入到栈 s2 中（==右括号== 的优先级 ==最低==）")]),t._v(" "),_("p",[t._v("e.否则，就将 s2 栈顶的运算符弹出，从 s1 中弹出两个（也可能是一个）操作数，进行运算，并把运算的结果压回 栈 s1")])]),t._v(" "),_("li",[_("p",[t._v("扫描到表达式结束，若最后栈 s2 中还有运算符，则依次弹出栈，并从 s1 中弹出两个（也可能是一个）操作数，进行运算，最后把运算结果压回栈 s1")])])])]),t._v(" "),_("p",[t._v("运算数的顺序不变")]),t._v(" "),_("ol",[_("li",[t._v("**后缀表达式求值的步骤：**左操作数+右操作数+运算符")])]),t._v(" "),_("blockquote",[_("ol",[_("li",[t._v("从左往右扫描下一个元素，直到，处理完所有元素")]),t._v(" "),_("li",[t._v("若扫描到操作数则压入栈中，并回到步骤1，否则执行步骤3")]),t._v(" "),_("li",[t._v("若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到步骤1")])])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("strong",[t._v("中缀表达式转后缀表达式步骤：")])])]),t._v(" "),_("blockquote",[_("p",[t._v("初始化一个栈，用于保存暂时还不能确定运算顺序的运算符，从左到右扫描各个元素，直到末尾")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("若扫描到 ==操作数==，则直接加入到后缀表达式")])]),t._v(" "),_("li",[_("p",[t._v("若扫描到 ==界限符==，则可能出现以下情况：")]),t._v(" "),_("p",[t._v('a.遇到 " ( " 则直接压入栈中，注意： " ( " 不加入后缀表达式')]),t._v(" "),_("p",[t._v('b.遇到 " ) " 则依次弹出栈内运算符，并加入后缀表达式，直到弹出 " ( " 为止')])]),t._v(" "),_("li",[_("p",[t._v('若扫描到 ==运算符==，依次弹出栈中 ==优先级高于或等于== 当前运算符的所有运算符，并加入后缀表达式，若遇到栈顶元素为 " ( " 或 栈空 则停止，然后把当前运算符压入栈中')])])])]),t._v(" "),_("h2",{attrs:{id:"_3-4-队列的应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-队列的应用"}},[t._v("#")]),t._v(" 3.4 队列的应用")]),t._v(" "),_("h2",{attrs:{id:"_3-5-数组和特殊矩阵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-数组和特殊矩阵"}},[t._v("#")]),t._v(" 3.5 数组和特殊矩阵")]),t._v(" "),_("h3",{attrs:{id:"_3-5-1-对称矩阵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-1-对称矩阵"}},[t._v("#")]),t._v(" 3.5.1 对称矩阵")]),t._v(" "),_("blockquote",[_("p",[t._v("对于n阶对称矩阵，只存放下三角部分（含主对角）的元素，压缩存储在表长为 n(n+1)/2 的顺序表中（数组下标从1开始）")]),t._v(" "),_("p",[t._v("若数组下标从0开始，则是 n(n+1)/2 - 1")]),t._v(" "),_("p",[t._v("==要注意数组下标是从0开始还是从1开始==")]),t._v(" "),_("p",[t._v("==C语言中数组下标是从 0 开始==")])]),t._v(" "),_("h3",{attrs:{id:"_3-5-2-三角矩阵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-2-三角矩阵"}},[t._v("#")]),t._v(" 3.5.2 三角矩阵")]),t._v(" "),_("blockquote",[_("p",[t._v("上三角区域的所有元素均为同一常量")]),t._v(" "),_("p",[t._v("下三角矩阵 A[1...n] [1...n] 压缩存储在数组 B[n(n+1)/2 + 1] （"),_("strong",[t._v("加 1 是多存储了一个常量")]),t._v("）中（数组下标从1开始）")]),t._v(" "),_("p",[t._v("若数组下标从0开始，则是 n(n+1)/2")])]),t._v(" "),_("h3",{attrs:{id:"_3-5-3-三对角矩阵-带状矩阵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-3-三对角矩阵-带状矩阵"}},[t._v("#")]),t._v(" 3.5.3 三对角矩阵（带状矩阵）")]),t._v(" "),_("blockquote",[_("p",[t._v("所有非零元素都集中在以主对角线为中心的 "),_("strong",[t._v("3 条对角线")]),t._v(" 的区域，其他区域的元素全为零")])]),t._v(" "),_("h3",{attrs:{id:"_3-5-4-稀疏矩阵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-4-稀疏矩阵"}},[t._v("#")]),t._v(" 3.5.4 稀疏矩阵")]),t._v(" "),_("blockquote",[_("p",[t._v("采用 "),_("strong",[t._v("三元组顺序表")]),t._v("、"),_("strong",[t._v("十字链表")]),t._v(" 存储非零元素")]),t._v(" "),_("p",[t._v("稀疏矩阵压缩存储之后，会失去随机存取的特性12")])])])}),[],!1,null,null,null);_.default=s.exports}}]);