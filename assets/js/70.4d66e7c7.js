(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{560:function(_,v,t){"use strict";t.r(v);var r=t(10),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"第八章-排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第八章-排序"}},[_._v("#")]),_._v(" 第八章--排序")]),_._v(" "),v("h2",{attrs:{id:"_8-1-插入类排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-插入类排序"}},[_._v("#")]),_._v(" 8.1 插入类排序")]),_._v(" "),v("h3",{attrs:{id:"_8-1-1-直接插入排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-1-直接插入排序"}},[_._v("#")]),_._v(" 8.1.1 直接插入排序")]),_._v(" "),v("blockquote",[v("p",[_._v("在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入位置")]),_._v(" "),v("p",[_._v("元素越"),v("strong",[_._v("有序")]),_._v("，直接插入排序的速度越"),v("strong",[_._v("快")])])]),_._v(" "),v("h3",{attrs:{id:"_8-1-2-折半插入排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-2-折半插入排序"}},[_._v("#")]),_._v(" 8.1.2 折半插入排序")]),_._v(" "),v("blockquote",[v("p",[_._v("从时间上比较，折半插入排序"),v("strong",[_._v("仅仅减少")]),_._v("了关键字的"),v("strong",[_._v("比较次数")]),_._v("，却没有减少记录的移动次数")]),_._v(" "),v("p",[v("strong",[_._v("比较次数")]),_._v(" 取决于表中"),v("strong",[_._v("元素个数")]),_._v("，与排序表的"),v("strong",[_._v("初始状态")]),_._v(" "),v("strong",[_._v("无关")])]),_._v(" "),v("p",[v("strong",[_._v("移动次数")]),_._v(" 取决于 "),v("strong",[_._v("排序表的初始状态")])])]),_._v(" "),v("h3",{attrs:{id:"_8-1-3-希尔排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-3-希尔排序"}},[_._v("#")]),_._v(" 8.1.3 希尔排序")]),_._v(" "),v("blockquote",[v("p",[_._v("希尔排序（缩小增量排序）：先取一个小于 n 的"),v("strong",[_._v("步长 d1")]),_._v("，所有距离为 d1 的倍数的记录放在同一组，组内部采用"),v("strong",[_._v("直接插入排序")])])]),_._v(" "),v("blockquote"),_._v(" "),v("h3",{attrs:{id:"插入类排序算法比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插入类排序算法比较"}},[_._v("#")]),_._v(" 插入类排序算法比较")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("em",[_._v("插入排序")])]),_._v(" "),v("th",[_._v("直接插入排序")]),_._v(" "),v("th",[_._v("折半插入排序")]),_._v(" "),v("th",[_._v("希尔排序")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("时间复杂度")]),_._v(" "),v("td",[_._v("最好情况：O(n)"),v("br"),_._v("最坏情况：O(n^2)"),v("br"),_._v("平均情况：O(n^2)")]),_._v(" "),v("td",[_._v("O(n^2)")]),_._v(" "),v("td",[_._v("优于直接插入排序"),v("br"),_._v("最坏情况：O(n^2)")])]),_._v(" "),v("tr",[v("td",[_._v("空间复杂度")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("O(1)")])]),_._v(" "),v("tr",[v("td",[_._v("稳定性")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("==不稳定==")])]),_._v(" "),v("tr",[v("td",[_._v("适用性")]),_._v(" "),v("td",[_._v("顺序表、链表")]),_._v(" "),v("td",[_._v("顺序表、链表")]),_._v(" "),v("td",[_._v("顺序表、链表")])])])]),_._v(" "),v("h2",{attrs:{id:"_8-2-交换类排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-交换类排序"}},[_._v("#")]),_._v(" 8.2 交换类排序")]),_._v(" "),v("h3",{attrs:{id:"_8-2-1-冒泡排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-1-冒泡排序"}},[_._v("#")]),_._v(" 8.2.1 冒泡排序")]),_._v(" "),v("blockquote",[v("p",[_._v("n 个元素，最多需要 n-1 趟排序，且"),v("strong",[_._v("每一趟排序")]),_._v("都可以使"),v("strong",[_._v("一个元素")]),_._v("移动到"),v("strong",[_._v("最终位置")])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("比较次数 = "),v("strong",[_._v("n(n-1)/2")])]),_._v(" "),v("li",[_._v("移动次数 = "),v("strong",[_._v("3n(n-1)/2")])])])]),_._v(" "),v("h3",{attrs:{id:"_8-2-2-快速排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-2-快速排序"}},[_._v("#")]),_._v(" 8.2.2 快速排序")]),_._v(" "),v("blockquote",[v("p",[_._v("快速排序是"),v("strong",[_._v("递归")]),_._v("的，需要借助"),v("strong",[_._v("系统栈")]),_._v("，且"),v("strong",[_._v("递归次数")]),_._v("与"),v("strong",[_._v("处理顺序无关")]),_._v("，只与 "),v("strong",[_._v("各元素的初始状态")]),_._v(" ==有关==")]),_._v(" "),v("p",[_._v("元素越"),v("strong",[_._v("无序")]),_._v("，快排的"),v("strong",[_._v("性能越好")]),_._v("；元素越有序，快排的性能越差")]),_._v(" "),v("p",[v("strong",[_._v("快速排序")]),_._v("是所有"),v("strong",[_._v("内部排序算法")]),_._v("中平均性能==最优==的排序算法")])]),_._v(" "),v("blockquote",[v("p",[_._v('排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一"趟" ，每趟只能确定枢轴元素的最终位置')]),_._v(" "),v("p",[_._v("快排的阶段性排序结果的特点：在"),v("strong",[_._v("第 i 趟")]),_._v("完成时，会有 **i 个以上的数（i 为枢轴元素个数）**出现在它最终将出现的位置")])]),_._v(" "),v("blockquote",[v("p",[_._v("基本思想：")]),_._v(" "),v("ol",[v("li",[_._v("选定 Pivot 中心轴")]),_._v(" "),v("li",[_._v("将 "),v("strong",[_._v("大于")]),_._v(" Pivot 的数字放在 Pivot 的 "),v("strong",[_._v("右边 R")])]),_._v(" "),v("li",[_._v("将 "),v("strong",[_._v("小于")]),_._v(" Pivot 的数字放在 Pivot 的 "),v("strong",[_._v("左边 L")])]),_._v(" "),v("li",[_._v("分别对左右子树序列重复前三步操作")])]),_._v(" "),v("p",[_._v("当每次的枢轴都把表等分为"),v("strong",[_._v("长度相近")]),_._v("的两个子表时，"),v("strong",[_._v("速度最快")])]),_._v(" "),v("p",[_._v("当表本身已经有序或逆序时，速度最慢")])]),_._v(" "),v("h3",{attrs:{id:"交换类排序算法比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#交换类排序算法比较"}},[_._v("#")]),_._v(" 交换类排序算法比较")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("em",[_._v("交换排序")])]),_._v(" "),v("th",[_._v("冒泡排序")]),_._v(" "),v("th",[_._v("快速排序")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("时间复杂度")]),_._v(" "),v("td",[_._v("最好情况（有序）：O(n)"),v("br"),_._v("最坏情况（逆序）：O(n^2)"),v("br"),_._v("平均情况：O(n^2)")]),_._v(" "),v("td",[_._v("最好情况（无序）：==O(n log2 n)=="),v("br"),_._v("最坏情况（有序）：O(n^2)"),v("br"),_._v("平均情况：O(n^2)")])]),_._v(" "),v("tr",[v("td",[_._v("空间复杂度")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("最好情况（栈的"),v("strong",[_._v("最小")]),_._v("递归深度）：==O(log2 n)=="),v("br"),_._v("最坏情况（栈的"),v("strong",[_._v("最大")]),_._v("递归深度）：==O(n)=="),v("br"),_._v("平均情况：==O(log2 n)==")])]),_._v(" "),v("tr",[v("td",[_._v("稳定性")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("==不稳定==")])]),_._v(" "),v("tr",[v("td",[_._v("适用性")]),_._v(" "),v("td",[_._v("顺序表、链表")]),_._v(" "),v("td",[_._v("顺序表")])])])]),_._v(" "),v("h2",{attrs:{id:"_8-3-选择类排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-选择类排序"}},[_._v("#")]),_._v(" 8.3 选择类排序")]),_._v(" "),v("h3",{attrs:{id:"_8-3-1-简单选择排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-1-简单选择排序"}},[_._v("#")]),_._v(" 8.3.1 简单选择排序")]),_._v(" "),v("blockquote",[v("p",[_._v("每趟都是从无序序列中一个个比较找到"),v("strong",[_._v("关键字最小")]),_._v("元素，将其和无序序列的首元素交换")]),_._v(" "),v("p",[_._v("每趟可以确定一个元素的最终位置")])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("元素间的"),v("strong",[_._v("比较次数")]),_._v("与"),v("strong",[_._v("序列的初始状态")]),_._v("  ==无关==，始终是 "),v("strong",[_._v("n(n-1)/2")]),_._v(" ，即 "),v("strong",[_._v("O(n^2) 次")])]),_._v(" "),v("li",[_._v("元素间的"),v("strong",[_._v("移动次数")]),_._v("小于 n - 1，即 "),v("strong",[_._v("O(n) 次")])])])]),_._v(" "),v("h3",{attrs:{id:"_8-3-2-堆排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-2-堆排序"}},[_._v("#")]),_._v(" 8.3.2 堆排序")]),_._v(" "),v("p",[v("strong",{staticStyle:{color:"#DD5145"}},[_._v("一般用堆来实现具有优先级的队列")]),_._v("。")]),_._v(" "),v("blockquote",[v("p",[_._v("采用"),v("strong",[_._v("完全二叉树")]),_._v("结构进行排序的方法")]),_._v(" "),v("p",[_._v("堆（Heap）的结构正好与该序列结构完全一致，即"),v("strong",[_._v("堆的序列就是完全二叉树的层次遍历")])]),_._v(" "),v("p",[_._v("二叉排序树会得到一个有序的序列，而堆则不一定能得到一个有序的序列")])]),_._v(" "),v("blockquote",[v("ul",[v("li",[v("strong",[_._v("大根堆：")]),_._v(" 最大元素存放在根结点")]),_._v(" "),v("li",[v("strong",[_._v("小根堆：")]),_._v(" 最小元素存放在根结点")]),_._v(" "),v("li",[_._v("左、右子树大小没有规定")])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("初始堆调整：自下而上，从右到左；先兄弟，后父子")]),_._v(" "),v("li",[_._v("输出堆顶元素，将堆的最后一个元素与堆顶元素交换，然后从上往下调整")]),_._v(" "),v("li",[_._v("插入元素，将新结点放在堆的末端，然后从下往上调整")])])]),_._v(" "),v("blockquote",[v("p",[_._v("在"),v("strong",[_._v("建立")]),_._v("含 n 个元素的堆时，关键字的"),v("strong",[_._v("比较次数")]),_._v(" <= "),v("strong",[_._v("4n")])]),_._v(" "),v("p",[_._v("每次"),v("strong",[_._v("调整")]),_._v("的时间复杂度为 O(h)，h 为完全二叉树的树高**【log2 n】+ 1**（向下取整）")])]),_._v(" "),v("blockquote",[v("p",[_._v("适用于"),v("strong",[_._v("从 n 个元素中获取前 k 个元素")]),_._v("，复杂度比较低")])]),_._v(" "),v("h3",{attrs:{id:"选择类排序算法比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#选择类排序算法比较"}},[_._v("#")]),_._v(" 选择类排序算法比较")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("em",[_._v("选择排序")])]),_._v(" "),v("th",[_._v("简单选择排序")]),_._v(" "),v("th",[_._v("堆排序")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("时间复杂度")]),_._v(" "),v("td",[_._v("O(n^2)")]),_._v(" "),v("td",[_._v("建立堆：O(n)"),v("br"),_._v("调整堆：==O(n log2 n)==")])]),_._v(" "),v("tr",[v("td",[_._v("空间复杂度")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("O(1)")])]),_._v(" "),v("tr",[v("td",[_._v("稳定性")]),_._v(" "),v("td",[_._v("==不稳定==")]),_._v(" "),v("td",[_._v("==不稳定==")])]),_._v(" "),v("tr",[v("td",[_._v("适用性")]),_._v(" "),v("td",[_._v("顺序表、链表")]),_._v(" "),v("td",[_._v("顺序表")])])])]),_._v(" "),v("h2",{attrs:{id:"_8-4-归并排序和基数排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-归并排序和基数排序"}},[_._v("#")]),_._v(" 8.4 归并排序和基数排序")]),_._v(" "),v("h3",{attrs:{id:"_8-4-1-二路归并排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-1-二路归并排序"}},[_._v("#")]),_._v(" 8.4.1 二路归并排序")]),_._v(" "),v("blockquote",[v("ul",[v("li",[v("strong",[_._v("归并")]),_._v(" 是指将两个或两个以上的有序表组合成一个新的有序表")]),_._v(" "),v("li",[v("strong",[_._v("二路归并")]),_._v(" 是指将每个子表长度为 1 的"),v("strong",[_._v("两两归并")]),_._v("，然后循环往复")]),_._v(" "),v("li",[_._v("一趟归并：双指针，不回溯")])]),_._v(" "),v("p",[_._v("**归并排序 **是本章所有的算法中 "),v("strong",[_._v("占用空间最多")]),_._v(" 的排序算法")])]),_._v(" "),v("blockquote",[v("p",[_._v("n 个元素进行 "),v("strong",[_._v("k 路归并排序")]),_._v("时，排序趟数 "),v("strong",[_._v("m = 【logk n】")]),_._v("（向上取整）")])]),_._v(" "),v("h3",{attrs:{id:"_8-4-2-基数排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-2-基数排序"}},[_._v("#")]),_._v(" 8.4.2 基数排序")]),_._v(" "),v("blockquote",[v("p",[_._v("基数排序（桶排序或数字排序）："),v("strong",{staticStyle:{color:"#DD5145"}},[_._v("不需要进行关键字的比较和元素的移动")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v('将整个关键字拆分为 d 位（或 "组"），做 d 趟 "'),v("strong",[_._v("分配")]),_._v('" 和 "'),v("strong",[_._v("收集")]),_._v('"')]),_._v(" "),v("li",[_._v("若关键字由 r 位子关键字构成，则需要建立 "),v("strong",[_._v("r 个队列")])])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("最高位优先（MSD）法")]),_._v(" "),v("li",[_._v("最低位优先（LSD）法")])]),_._v(" "),v("p",[_._v("适用于：1.数据元素的关键字可以方便拆分为 d 组，且 d 较小\n2.每组关键字的取值范围不大，即 r 较小\n3.数据元素个数 n 较大")])]),_._v(" "),v("h3",{attrs:{id:"归并与基数排序比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#归并与基数排序比较"}},[_._v("#")]),_._v(" 归并与基数排序比较")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th"),_._v(" "),v("th",[_._v("归并排序")]),_._v(" "),v("th",[_._v("基数排序")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("时间复杂度")]),_._v(" "),v("td",[_._v("==O(n log2 n)==")]),_._v(" "),v("td",[v("strong",[_._v("O( d(n+r) )")])])]),_._v(" "),v("tr",[v("td",[_._v("空间复杂度")]),_._v(" "),v("td",[_._v("==O(n)==")]),_._v(" "),v("td",[_._v("==O(r)==")])]),_._v(" "),v("tr",[v("td",[_._v("稳定性")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("稳定")])]),_._v(" "),v("tr",[v("td",[_._v("适用性")]),_._v(" "),v("td",[_._v("顺序表")]),_._v(" "),v("td",[_._v("顺序表、链表")])])])]),_._v(" "),v("h2",{attrs:{id:"_8-5-内部排序算法总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-内部排序算法总结"}},[_._v("#")]),_._v(" 8.5 内部排序算法总结")]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("每趟排序 "),v("strong",[_._v("无法确定")]),_._v(" 元素最终位置的是 "),v("strong",[_._v("插入类排序")]),_._v("（插入排序、希尔排序）、"),v("strong",[_._v("归并排序")]),_._v("、"),v("strong",[_._v("基数排序")])]),_._v(" "),v("li",[_._v("每趟排序均 "),v("strong",[_._v("可确定")]),_._v(" 一个元素最终位置的是 "),v("strong",[_._v("交换类排序")]),_._v("（冒泡、快速排序）、"),v("strong",[_._v("选择类排序")]),_._v("（简单选择、堆排序）")])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[v("strong",[_._v("排序趟数")]),_._v(" 与 元素的 "),v("strong",[_._v("初始状态")]),_._v(" ==有关== 的是 "),v("strong",[_._v("快速排序")])]),_._v(" "),v("li",[_._v("与 "),v("strong",[_._v("初始状态")]),_._v(" ==无关== 的是 "),v("strong",[_._v("插入类排序")]),_._v(" （插入排序、希尔排序）、"),v("strong",[_._v("冒泡排序")]),_._v("、"),v("strong",[_._v("选择类排序")]),_._v("（简单选择、堆排序）、"),v("strong",[_._v("归并排序")])])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("若 n 比较 "),v("strong",[_._v("小")]),_._v(" 时，可采用 直接插入排序、简单选择排序")]),_._v(" "),v("li",[_._v("若 n 比较 "),v("strong",[_._v("大")]),_._v(" 时，可采用 时间复杂度为 "),v("strong",[_._v("O(n log2 n)")]),_._v(" 的 "),v("strong",[_._v("快速排序")]),_._v("、"),v("strong",[_._v("堆排序")]),_._v("、"),v("strong",[_._v("归并排序")])]),_._v(" "),v("li",[_._v("若文件的 "),v("strong",[_._v("初始状态")]),_._v(" 已按关键字基本 "),v("strong",[_._v("有序")]),_._v("，可采用 "),v("strong",[_._v("直接插入排序")]),_._v("、"),v("strong",[_._v("冒泡排序")])])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("一般需要采用 ==顺序结构== 存储的排序算法是 "),v("strong",[_._v("快速排序")]),_._v("、"),v("strong",[_._v("堆排序")]),_._v("、"),v("strong",[_._v("归并排序")])]),_._v(" "),v("li",[_._v("其他算法可以采用顺序结构和链式结构")])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[v("p",[_._v("平均 "),v("strong",[_._v("时间复杂度")]),_._v(" 为 "),v("strong",[_._v("O(n log2 n)")]),_._v(" 的 "),v("strong",[_._v("稳定")]),_._v(" 排序算法只有 "),v("strong",[_._v("归并排序")])])]),_._v(" "),v("li",[v("p",[_._v("==不稳定== 的排序算法："),v("strong",[_._v("希尔排序")]),_._v("、"),v("strong",[_._v("快速排序")]),_._v("、"),v("strong",[_._v("选择类排序")]),_._v("（简单选择排序、堆排序）")])])])]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("算法的 "),v("strong",[_._v("时间复杂度")]),_._v(" 和 "),v("strong",[_._v("比较次数")]),_._v(" 与 元素的初始状态 ==无关== 的是 "),v("strong",[_._v("简单选择排序")]),_._v("、"),v("strong",[_._v("归并排序")]),_._v("、"),v("strong",[_._v("基数排序")])]),_._v(" "),v("li",[_._v("对于任意 n 个关键字排序的 "),v("strong",[_._v("比较次数")]),_._v(" "),v("strong",[_._v("至少")]),_._v(" 为**【log2 (n!)】**次（向上取整）")])])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("排序算法")]),_._v(" "),v("th",[_._v("稳定性")]),_._v(" "),v("th",[_._v("时间复杂度")]),_._v(" "),v("th",[_._v("空间复杂度")]),_._v(" "),v("th",[_._v("排序趟数")]),_._v(" "),v("th",[_._v("与元素的初始状态")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("直接插入排序")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("最好情况：O(n)"),v("br"),_._v("最坏情况：O(n^2)"),v("br"),_._v("平均情况：O(n^2)")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("n-1")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[_._v("折半插入排序")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("O(n^2)")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("n-1")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[_._v("希尔排序")]),_._v(" "),v("td",[_._v("==不稳定==")]),_._v(" "),v("td",[_._v("优于直接插入排序"),v("br"),_._v("最坏情况：O(n^2)")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("无法定量分析")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[_._v("冒泡排序")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("最好情况（有序）：O(n)"),v("br"),_._v("最坏情况（逆序）：O(n^2)"),v("br"),_._v("平均情况：O(n^2)")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("n-1")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("快速排序")])]),_._v(" "),v("td",[_._v("==不稳定==")]),_._v(" "),v("td",[_._v("最好情况（无序）：==O(n log2 n)=="),v("br"),_._v("最坏情况（有序）：O(n^2)"),v("br"),_._v("平均情况：==O(n log2 n)==")]),_._v(" "),v("td",[_._v("最好情况：O(log2 n)"),v("br"),_._v("最坏情况：O(n)"),v("br"),_._v("平均情况：O(log2 n)")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("==有关==")])]),_._v(" "),v("tr",[v("td",[_._v("简单选择排序")]),_._v(" "),v("td",[_._v("==不稳定==")]),_._v(" "),v("td",[_._v("三者都是：O(n^2)")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("n-1")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[_._v("堆排序")]),_._v(" "),v("td",[_._v("==不稳定==")]),_._v(" "),v("td",[_._v("建立堆：O(n)"),v("br"),_._v("调整堆：==O(n log2 n)==")]),_._v(" "),v("td",[_._v("O(1)")]),_._v(" "),v("td",[_._v("n-1")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[_._v("2路归并排序")]),_._v(" "),v("td",[v("strong",[_._v("稳定")])]),_._v(" "),v("td",[_._v("三者都是：==O(n log2 n)==")]),_._v(" "),v("td",[_._v("==O(n)==")]),_._v(" "),v("td",[_._v("log2 n")]),_._v(" "),v("td",[_._v("\\")])]),_._v(" "),v("tr",[v("td",[_._v("基数排序")]),_._v(" "),v("td",[_._v("稳定")]),_._v(" "),v("td",[_._v("三者都是：O( d(n+r) )")]),_._v(" "),v("td",[v("strong",[_._v("O(r)")])]),_._v(" "),v("td",[_._v("不需要进行比较和移动")]),_._v(" "),v("td")])])]),_._v(" "),v("h2",{attrs:{id:"_8-6-外部排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-外部排序"}},[_._v("#")]),_._v(" 8.6 外部排序")]),_._v(" "),v("h3",{attrs:{id:"_8-6-1-外部排序的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-1-外部排序的方法"}},[_._v("#")]),_._v(" 8.6.1 外部排序的方法")]),_._v(" "),v("p",[_._v("外部排序：数据元素太多，无法一次全部读入内存进行排序，在排序过程中需要多次进行内存和外存的交换")]),_._v(" "),v("p",[_._v("外部排序通常采用 "),v("strong",[_._v("归并排序法")])]),_._v(" "),v("p",[_._v("最少只需要在内存中分配 3 快大小的缓冲区即可对任意一个大文件进行排序")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("外部排序的总时间 = 内部排序所需时间 + 外存信息读写时间 + 内部归并所需时间")])]),_._v(" "),v("p",[_._v("外存信息读写时间（以磁盘块为单位）远大于内部排序时间和内部归并时间，应该着力减少 I/O 次数")])]),_._v(" "),v("blockquote",[v("p",[_._v("一般对 r 个初始归并段，做 k 路平衡归并，归并树可用"),v("strong",[_._v("严格 k 叉树")]),_._v("（只有度为 0 和 k 的结点的 k 叉树）来表示")]),_._v(" "),v("p",[v("strong",[_._v("树高 - 1 = 【logk r】（向上取整）= 归并趟数S")])]),_._v(" "),v("p",[_._v("只要增大归并路数 k ，或减少初始归并段个数 r ，即可减少归并趟数S，进而减少磁盘 I/O 次数")])]),_._v(" "),v("h3",{attrs:{id:"_8-6-2-败者树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-2-败者树"}},[_._v("#")]),_._v(" 8.6.2 败者树")]),_._v(" "),v("p",[_._v('引入 "败者树" 减少关键字对比次数')]),_._v(" "),v("blockquote",[v("p",[_._v("对于 k 路归并，第一次构造败者树需要对比关键字 k-1 次")]),_._v(" "),v("p",[_._v("使用败者树后，"),v("strong",[_._v("选出最小元素")]),_._v("，只需要对比关键字 【log2 k】次（向上取整）")]),_._v(" "),v("p",[_._v("使用败者树后，内部归并的比较次数与 k 无关了")])]),_._v(" "),v("p",[_._v("只要空间允许，适当地增大归并路数 k 将有效减少归并树的高度，从而减少 I/O 次数，提高外部排序的速度")]),_._v(" "),v("h3",{attrs:{id:"_8-6-3-置换-选择排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-3-置换-选择排序"}},[_._v("#")]),_._v(" 8.6.3 置换-选择排序")]),_._v(" "),v("p",[_._v("利用置换-选择排序（生成初始归并段）增大归并段长度，从而减少初始归并段的个数")]),_._v(" "),v("blockquote",[v("p",[_._v("初始待排序文件为 FI，初始归并段输出文件为 FO，内存工作区为 WA，且 FO 和 WA 的初始态为空")]),_._v(" "),v("p",[_._v("每个初始归并段的长度可以超过内存工作区 WA 的大小限制")])]),_._v(" "),v("h3",{attrs:{id:"_8-6-4-最佳归并树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-4-最佳归并树"}},[_._v("#")]),_._v(" 8.6.4 最佳归并树")]),_._v(" "),v("p",[_._v("归并树可以采用"),v("strong",[_._v("哈夫曼树")]),_._v("的思想，总的 I/O 次数最少的为最佳归并树")]),_._v(" "),v("p",[_._v("最佳归并树的作用：设计 m 路归并排序的优化方案")]),_._v(" "),v("p",[_._v("归并过程中的 "),v("strong",[_._v("磁盘 I/O 次数 = 归并树的 WPL * 2")])]),_._v(" "),v("p",[_._v("若初始归并段不足以构成一颗严格的 k 叉归并树时，需要添加长度为 0 的 "),v("strong",[_._v('"虚段"')]),_._v("，再进行 k 叉哈夫曼树的构造")]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v('若**（初始归并段数量 - 1）%（k - 1）** = 0 时，则不需要添加 "虚段"')]),_._v(" "),v("li",[_._v('若（初始归并段数量 - 1）%（k - 1） = u（u不等于 0）时，则需要补充**（k-1）- u** 个 "虚段"')])])])])}),[],!1,null,null,null);v.default=s.exports}}]);