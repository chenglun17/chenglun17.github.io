(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{700:function(v,_,e){"use strict";e.r(_);var o=e(10),c=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"七、异步方案的比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、异步方案的比较"}},[v._v("#")]),v._v(" 七、异步方案的比较")]),v._v(" "),_("p",[v._v("异步解决方案的发展历程：回调函数 --- Promise --- Generator --- async / await。")]),v._v(" "),_("p",[v._v("后三种方案是为解决传统的回调函数而提出的。而"),_("code",[v._v("async/await")]),v._v("又是"),_("code",[v._v("Generator")]),v._v("函数的语法糖。")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("Promise")]),v._v(" 的内部错误使用"),_("code",[v._v("try catch")]),v._v("捕获不到，只能用"),_("code",[v._v("then")]),v._v("的第二个回调或"),_("code",[v._v("catch")]),v._v("来捕获，而"),_("code",[v._v("async/await")]),v._v("的错误可以用"),_("code",[v._v("try catch")]),v._v("捕获")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("Promise")]),v._v(" 一旦新建就会立即执行，"),_("strong",[v._v("不会阻塞后面的代码")]),v._v("，而"),_("code",[v._v("async")]),v._v("函数中 "),_("code",[v._v("await")]),v._v(" 后面是 "),_("code",[v._v("Promise")]),v._v(" 对象会"),_("strong",[v._v("阻塞后面的代码")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("async")]),v._v("函数会隐式地返回一个"),_("code",[v._v("Promise")]),v._v("，该"),_("code",[v._v("Promise")]),v._v("的"),_("code",[v._v("reosolve")]),v._v("值就是函数 return 的值。")])]),v._v(" "),_("li",[_("p",[v._v("使用"),_("code",[v._v("async")]),v._v("函数可以让代码更加简洁，不需要像"),_("code",[v._v("Promise")]),v._v("一样需要调用"),_("code",[v._v("then")]),v._v("方法来获取返回值，不需要写匿名函数处理"),_("code",[v._v("Promise")]),v._v("的"),_("code",[v._v("resolve")]),v._v(" 值，也不需要定义多余的 data 变量，还避免了嵌套代码。")])])])])}),[],!1,null,null,null);_.default=c.exports}}]);