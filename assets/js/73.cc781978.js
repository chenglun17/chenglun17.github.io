(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{563:function(_,v,t){"use strict";t.r(v);var a=t(10),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"第五章-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第五章-树"}},[_._v("#")]),_._v(" 第五章--树")]),_._v(" "),v("h2",{attrs:{id:"_5-1-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-树"}},[_._v("#")]),_._v(" 5.1 树")]),_._v(" "),v("h3",{attrs:{id:"_5-1-1-树的存储结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-树的存储结构"}},[_._v("#")]),_._v(" 5.1.1 树的存储结构")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("双亲表示法")])])]),_._v(" "),v("blockquote",[v("p",[_._v("找双亲容易，找孩子难")]),_._v(" "),v("p",[_._v("双亲结点结构：| data | parent |")])]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("孩子链表表示法")])])]),_._v(" "),v("blockquote",[v("p",[_._v("找孩子容易，找双亲难")]),_._v(" "),v("p",[_._v("孩子结点结构：| child | next |")]),_._v(" "),v("p",[_._v("双亲结点结构：| data | firstchild |")])]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("孩子兄弟表示法（二叉树表示法）")])])]),_._v(" "),v("blockquote",[v("p",[_._v("方便实现树转换为二叉树，找孩子容易，找双亲难，左孩有兄")]),_._v(" "),v("p",[_._v("结点结构：| firstchild | data | nextsibling |")])]),_._v(" "),v("h3",{attrs:{id:"_5-1-2-树的性质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-2-树的性质"}},[_._v("#")]),_._v(" 5.1.2 树的性质")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[_._v("树的结点个数 = 所有结点的度数之和 + 1")])]),_._v(" "),v("li",[v("p",[_._v("对于 m度树，定义叶子结点个数为 n0，度为1的结点个数为 n1，...，度为m的结点个数为 nm，")]),_._v(" "),v("p",[_._v("则有 n0= n2 + 2 n3 + 3 n4 + ... + (n-1) nm + 1")])]),_._v(" "),v("li",[v("p",[_._v("度为 m 的树中 ==第 i 层== 上"),v("strong",[_._v("至多")]),_._v("有 m ^(i-1) 个结点（ i >1)")])]),_._v(" "),v("li",[v("p",[_._v("高度(深度)为 h 的 m叉树"),v("strong",[_._v("至多")]),_._v("有 (m^h - 1) / (m-1) 个结点，"),v("strong",[_._v("至少")]),_._v("有 h 个结点")])]),_._v(" "),v("li",[v("p",[_._v("具有 n个结点的 m叉树 的 ==最小高度== 为 【log m [n(m-1) +1]】(向上取整)，==最大高度== 为 n（每层结点最少）")])]),_._v(" "),v("li",[v("p",[_._v("n 个结点的树中有 n-1 条边")])])])]),_._v(" "),v("h2",{attrs:{id:"_5-3-二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-二叉树"}},[_._v("#")]),_._v(" 5.3 二叉树")]),_._v(" "),v("p",[_._v("二叉树是有序树，但度为2的树可能是无序树，二叉树的每个结点至多只有两棵子树，且子树有左右之分，次序不能颠倒")]),_._v(" "),v("h3",{attrs:{id:"_5-2-1-二叉树的性质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-二叉树的性质"}},[_._v("#")]),_._v(" 5.2.1 二叉树的性质")]),_._v(" "),v("blockquote",[v("ol",[v("li",[_._v("非空二叉树上的 叶子结点数 = 度为2 的结点数 + 1，即 n0 = n2 + 1")]),_._v(" "),v("li",[_._v("非空二叉树上 ==第 k 层== 上"),v("strong",[_._v("至多")]),_._v("有 "),v("strong",[_._v("2 ^(k-1)")]),_._v(" 个结点（k >=1）")]),_._v(" "),v("li",[_._v("高度为 h 的二叉树"),v("strong",[_._v("至多")]),_._v("有 "),v("strong",[_._v("2^h - 1")]),_._v(" 个结点（h >=1）")]),_._v(" "),v("li",[_._v("具有 n 个 (n >0) 结点的 "),v("strong",[_._v("完全二叉树")]),_._v(" 的 ==高度==为 "),v("strong",[_._v("【log 2 (n+1)】 (向上取整)")]),_._v(" 或 【log 2 n】+ 1 (向下取整)")]),_._v(" "),v("li",[_._v("对 "),v("strong",[_._v("完全二叉树")]),_._v(" 按从上到下、从左到右的顺序依次执行编号1，2，...，n，则有以下关系：\n"),v("ul",[v("li",[_._v("当 i > 1 时，结点 i 的双亲的编号为【2 / i】(向下取整)")]),_._v(" "),v("li",[_._v("当 2i <= n 时，结点 i 的左孩子编号为 2i，否则无左孩子")]),_._v(" "),v("li",[_._v("当 2i +1 <= n 时，结点 i 的右孩子编号为 2i + 1，否则无右孩子")]),_._v(" "),v("li",[_._v("结点 i 所在 ==层次（深度）== 为【log 2 i】+1 (向下取整)")])])])])]),_._v(" "),v("h3",{attrs:{id:"_5-2-2-二叉树的存储结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-二叉树的存储结构"}},[_._v("#")]),_._v(" 5.2.2 二叉树的存储结构")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[v("strong",[_._v("顺序存储结构")])]),_._v(" "),v("p",[_._v("适用于 满二叉树和完全二叉树")]),_._v(" "),v("p",[_._v("对于一般的二叉树，比较浪费存储空间，最坏的情况，高度为 h 且只有 h 个结点的单支树需要占近 2^h - 1 个存储单元")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("链式存储结构")])]),_._v(" "),v("p",[_._v("二叉树链式存储的结点结构： | lchild | data | rchild |")]),_._v(" "),v("p",[_._v("含有 n 个结点的二叉链表中，含有 n+1 个空链域")]),_._v(" "),v("p",[_._v("三叉链表的存储结构： | lchild | data | parent | rchild |")])])])]),_._v(" "),v("h3",{attrs:{id:"_5-2-3-二叉树的遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-3-二叉树的遍历"}},[_._v("#")]),_._v(" 5.2.3 二叉树的遍历")]),_._v(" "),v("blockquote",[v("p",[_._v("先序（NLR），中序（LNR），后序（LRN）")]),_._v(" "),v("p",[_._v("遍历是指按照某条路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次")]),_._v(" "),v("p",[_._v("时间复杂度均为 O(n)")]),_._v(" "),v("p",[_._v("最坏情况下，二叉树是有 n个结点且深度为 n 的单枝树，空间复杂度为 O(n)")])]),_._v(" "),v("h3",{attrs:{id:"_5-2-4-特殊二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-4-特殊二叉树"}},[_._v("#")]),_._v(" 5.2.4 特殊二叉树")]),_._v(" "),v("p",[v("strong",[_._v("1. 满二叉树")])]),_._v(" "),v("p",[v("strong",[_._v("2. 完全二叉树")])]),_._v(" "),v("blockquote",[v("p",[_._v("若 "),v("strong",[_._v("i <= 【n/2】(向下取整)")]),_._v("，则结点 i 为"),v("strong",[_._v("非终端结点")]),_._v("，否则为叶子结点")]),_._v(" "),v("p",[_._v("叶子结点只可能在最底下两层出现，且"),v("strong",[_._v("叶子结点")]),_._v("的范围为 "),v("strong",[_._v("[n/2 + 1，n]")])]),_._v(" "),v("p",[_._v("度为1 的结点个数最多只有一个（即度为1的个数只能有1个或0个），且该结点只有左孩子没有右孩子")]),_._v(" "),v("p",[_._v("n 个结点的完全二叉树的"),v("strong",[_._v("树高")]),_._v(" $log_2{(n+1)}$ ("),v("strong",[_._v("向上取整")]),_._v(") 或 $log_2{n} +1$ ("),v("strong",[_._v("向下取整")]),_._v(")")])]),_._v(" "),v("p",[v("strong",[_._v("3. 二叉排序树（BST）")])]),_._v(" "),v("blockquote",[v("p",[_._v("结点的关键字：左子树 < 根结点 < 右子树")])]),_._v(" "),v("p",[v("strong",[_._v("4. 平衡二叉树（AVL树）")])]),_._v(" "),v("blockquote",[v("p",[_._v("树上任一结点的左子树和右子树的深度之差不超过 1")])]),_._v(" "),v("h2",{attrs:{id:"_5-4-线索二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-线索二叉树"}},[_._v("#")]),_._v(" 5.4 线索二叉树")]),_._v(" "),v("p",[_._v("二叉树是一种逻辑结构，而线索二叉树是加上了"),v("strong",[_._v("线索")]),_._v("后的链表结构，即是一种物理结构（存储结构）")]),_._v(" "),v("p",[_._v("线索：是指向结点前驱和后继的指针")]),_._v(" "),v("p",[_._v("线索化的实质：遍历一次二叉树")]),_._v(" "),v("blockquote",[v("p",[_._v("引入线索二叉树的目的：为了加快查找结点前驱和后继的速度")]),_._v(" "),v("p",[_._v("一颗任意的二叉树，也任意使用 先序/中序/后序 线索化，则线索化后其空链域最多有 2 个")]),_._v(" "),v("p",[_._v("使用了线索二叉树后，前序和中序遍历将不需要栈的支持，但后序遍历仍需要栈的支持")]),_._v(" "),v("p",[_._v("对于后序遍历的线索二叉树，找结点的直接后继依然困难")])]),_._v(" "),v("h2",{attrs:{id:"_5-5-树和森林"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-树和森林"}},[_._v("#")]),_._v(" 5.5 树和森林")]),_._v(" "),v("h3",{attrs:{id:"_5-5-1-树的存储结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-1-树的存储结构"}},[_._v("#")]),_._v(" 5.5.1 树的存储结构")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("双亲表示法")])])]),_._v(" "),v("blockquote",[v("p",[_._v("结点结构：| data | parent |")]),_._v(" "),v("p",[_._v("找双亲容易，找孩子难")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("strong",[_._v("孩子表示法")]),_._v("（孩子链表表示法）")])]),_._v(" "),v("blockquote",[v("p",[_._v("双亲结点结构：| data | firstchild |")]),_._v(" "),v("p",[_._v("孩子结点结构：| child | next |")]),_._v(" "),v("p",[_._v("找孩子容易，找双亲难")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("strong",[_._v("孩子兄弟表示法")]),_._v("（二叉树表示法）")])]),_._v(" "),v("blockquote",[v("p",[_._v("二叉链表结点：| firschild | data | nextsibling |")]),_._v(" "),v("p",[_._v("左孩右兄，找孩子容易，找双亲难")])]),_._v(" "),v("h3",{attrs:{id:"_5-5-2-树、森林与二叉树的转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-2-树、森林与二叉树的转换"}},[_._v("#")]),_._v(" 5.5.2 树、森林与二叉树的转换")]),_._v(" "),v("p",[_._v("任何一颗和树对应的二叉树，其结点的右子树一定为空")]),_._v(" "),v("h3",{attrs:{id:"_5-5-3-树和森林的遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-3-树和森林的遍历"}},[_._v("#")]),_._v(" 5.5.3 树和森林的遍历")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[v("strong",[_._v("树的遍历")])]),_._v(" "),v("p",[_._v("先根遍历")]),_._v(" "),v("p",[_._v("后根遍历")]),_._v(" "),v("p",[_._v("树没有中序遍历")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("森林的遍历")])]),_._v(" "),v("p",[_._v("先序遍历森林")]),_._v(" "),v("p",[_._v("中序遍历森林")])])]),_._v(" "),v("p",[_._v("树的"),v("strong",[_._v("先根")]),_._v("遍历 = 对应二叉树的"),v("strong",[_._v("先序")]),_._v("遍历 = 森林的先序遍历")]),_._v(" "),v("p",[_._v("树的"),v("strong",[_._v("后根")]),_._v("遍历 = 对应二叉树的"),v("strong",[_._v("中序")]),_._v("遍历 = 森林的中序遍历")])]),_._v(" "),v("h2",{attrs:{id:"_5-6-树与二叉树的应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-树与二叉树的应用"}},[_._v("#")]),_._v(" 5.6 树与二叉树的应用")]),_._v(" "),v("h3",{attrs:{id:"_5-6-1-哈夫曼树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-1-哈夫曼树"}},[_._v("#")]),_._v(" 5.6.1 哈夫曼树")]),_._v(" "),v("p",[_._v("在含有 n 个"),v("strong",[_._v("带权叶结点")]),_._v("的二叉树中，其中"),v("strong",[_._v("带权路径长度（WPL，Weighted Path Length）"),v("strong",[_._v("最小的二叉树称为")]),_._v("哈夫曼树")]),_._v("（最优二叉树）")]),_._v(" "),v("blockquote",[v("p",[_._v("WPL的定义：WPL = 所有（叶结点的权值Wi * 该结点的深度Li）")]),_._v(" "),v("p",[_._v("在哈夫曼树中，WPL = 所有非叶结点的权值和")])]),_._v(" "),v("blockquote",[v("p",[_._v("满二叉树不一定是哈夫曼树（哈夫曼树本质不是二叉树）")]),_._v(" "),v("p",[_._v("哈夫曼树不一定是完全二叉树")]),_._v(" "),v("p",[_._v("哈夫曼树只有 0 度结点和 2 度结点")]),_._v(" "),v("p",[_._v("哈夫曼树不唯一，因为左、右子树可以交换，但WPL值唯一")]),_._v(" "),v("p",[_._v("==n 个叶子结点构造哈夫曼树，则总结点数为 2n - 1==")])]),_._v(" "),v("h3",{attrs:{id:"_5-6-2哈夫曼编码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-2哈夫曼编码"}},[_._v("#")]),_._v(" 5.6.2哈夫曼编码")]),_._v(" "),v("blockquote",[v("p",[_._v("前缀编码：没有一个编码是另一个编码的前缀")]),_._v(" "),v("p",[_._v("左0右1")])]),_._v(" "),v("h3",{attrs:{id:"_5-6-3-并查集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-3-并查集"}},[_._v("#")]),_._v(" 5.6.3 并查集")]),_._v(" "),v("p",[_._v("并查集的原理")]),_._v(" "),v("blockquote",[v("p",[_._v("用集合中的一个元素代表集合")])]),_._v(" "),v("p",[_._v("并查集的应用")]),_._v(" "),v("blockquote",[v("p",[_._v("判断连通性、判断环")]),_._v(" "),v("p",[_._v("Kruskal算法 = 排序 + 并查集")])]),_._v(" "),v("p",[_._v("并查集的操作")]),_._v(" "),v("blockquote",[v("p",[_._v("查询 find：判断两个点是否属于同一集合")]),_._v(" "),v("p",[_._v("合并 union：将两个点所在集合合并")])]),_._v(" "),v("p",[_._v("并查集的存储方式")]),_._v(" "),v("blockquote",[v("p",[_._v("逻辑：通常用 树（森林）的 ==双亲表示== 作为并查集的存储结构")]),_._v(" "),v("p",[_._v("找双亲容易，找孩子难，双亲结点结构：| data | parent |")])]),_._v(" "),v("blockquote",[v("p",[_._v("存储：数组")]),_._v(" "),v("p",[_._v("数组元素的下标代表元素名，根结点的下标代表集合名，根结点的双亲结点为负数")])])])}),[],!1,null,null,null);v.default=r.exports}}]);